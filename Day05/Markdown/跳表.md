#### 跳表

​		它是一种各方面性能都比较优秀的动态数据结构，可以支持快速的插入、删 除、查找操作，写起来也不复杂，甚至可以替代红黑树（Red-black tree）。

#### 如何理解“跳表”？

​		对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数 据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。

![image-20210813083954030](C:\Users\liuya\AppData\Roaming\Typora\typora-user-images\image-20210813083954030.png)

​		那怎么来提高查找效率呢？如果像图中那样，对链表建立一级“索引”，查找起来是不是就 会更快一些呢？每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作索引或索引 层。你可以看我画的图。图中的 down 表示 down 指针，指向下一级结点。

![image-20210813084135213](C:\Users\liuya\AppData\Roaming\Typora\typora-user-images\image-20210813084135213.png)

​		如果我们现在要查找某个结点，比如 16。我们可以先在索引层遍历，当遍历到索引层中值 为 13 的结点时，我们发现下一个结点是 17，那要查找的结点 16 肯定就在这两个结点之 间。然后我们通过索引层结点的 down 指针，下降到原始链表这一层，继续遍历。这个时 候，我们只需要再遍历 2 个结点，就可以找到值等于 16 的这个结点了。这样，原来如果要 查找 16，需要遍历 10 个结点，现在只需要遍历 7 个结点

时间复杂度是O(logn)，空间复杂度是O(n)

#### 高效的动态插入和删除

​		对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。但是，对于跳表来说，我们讲 过查找某个结点的的时间复杂度是 O(logn)，所以这里查找某个数据应该插入的位置，方法 也是类似的，时间复杂度也是 O(logn)。我画了一张图，你可以很清晰地看到插入的过程。

![image-20210813090528523](C:\Users\liuya\AppData\Roaming\Typora\typora-user-images\image-20210813090528523.png)

#### 跳表索引动态更新

​		当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点 之间数据非常多的情况。极端情况下，跳表还会退化成单链表

![image-20210813090721921](C:\Users\liuya\AppData\Roaming\Typora\typora-user-images\image-20210813090721921.png)

​		作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是 说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插 入、删除操作性能下降。如果你了解红黑树、AVL 树这样平衡二叉树，你就知道它们是通过左右旋的方式保持左右 子树的大小平衡（如果不了解也没关系，我们后面会讲），而跳表是通过随机函数来维护前 面提到的“平衡性”。

当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。如何 选择加入哪些索引层呢？ 我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。

![image-20210813091013453](C:\Users\liuya\AppData\Roaming\Typora\typora-user-images\image-20210813091013453.png)

